#pragma config(Sensor, S1,     color_sensor,   sensorColorNxtRED)
#pragma config(Sensor, S2,     light_sensor,   sensorLightActive)
#pragma config(Sensor, S3,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          motor_right,   tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          motor_left,    tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(NXT)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

long nLastXmitTimeStamp = nPgmTime;
long nDeltaTime         = 0;

const int kMaxSizeOfMessage = 30;
const int INBOX = 5;

void check_bleutooth(string *s){
	TFileIOResult nBTCmdRdErrorStatus;
  int nSizeOfMessage;
  ubyte nRcvBuffer[kMaxSizeOfMessage];

	while(1){
		//wait on bleutooth
		 nSizeOfMessage = cCmdMessageGetSize(INBOX);

    if (nSizeOfMessage > kMaxSizeOfMessage){
      nSizeOfMessage = kMaxSizeOfMessage;
    }

    if (nSizeOfMessage > 0){
    	nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
    	nRcvBuffer[nSizeOfMessage] = '\0';
    	//string s = "";
    	stringFromChars(*s, (char *) nRcvBuffer);
    	displayCenteredBigTextLine(4, *s);
    	break;
    }

    wait1Msec(100);
	}
}

void need_for_speed(int begin_value_s1, int begin_value_s2){
//using float variable for the sensors to have the most 	accurate
float color;
	float  light;
	float sonar;
// reading the sensor value 
	light = SensorValue[S2];
	color = SensorValue[S1];
	sonar = SensorValue[S3];
	// displaying the values from above
	nxtDisplayTextLine(1, "color: %d", color);
	nxtDisplayTextLine(2, "light: %d", light);
	nxtDisplayTextLine(3, "sonar: %d", sonar );
// if an object is less than 15 centimeters the top
	if(sonar <15) {
		setMultipleMotors(0,motorA,motorB);
		string s = "";
		check_bleutooth(&s);
	}
	//redirect the robot by using the light sensor 
	else if (light < 65){
		float formule;
		float omrek;
		float maal = 0;
				omrek = 65-light;
				formule = (65+(omrek)*(1+(2/3)));
		nxtDisplayTextLine(4, "omrekrechts: %d", omrek );
	
							if (omrek< 10){maal =1.2;}
								else if(omrek>25){maal = 2 +((omrek-25)*0.1);}
									else{(maal = 1.2+(omrek-10)*0.055);}
		motor(motorA) = formule;//50+((60-light)*2.5)
		motor(motorB) =45-(omrek*maal);//35  //0
	}
	// redirecting the robot by using hte color sensor
	else if(color < 48) {//vorige waarde: 4
	// float variables for best accurate values
	float formule;
		float omrek;
		float maal =0;
	
				omrek = 48-color;
				formule = (65+(omrek)*(1+(2/3)));
							nxtDisplayTextLine(5, "omreklinks: %d", omrek );
							if (omrek< 10){maal = 1.2;}
								else if(omrek>25){maal = 2 + ((omrek - 25)*0.1);}
									else{maal=(1.2+(omrek-10)*0.055);}
		
		motor(motorA) = 45-(omrek*maal);//0
		motor(motorB) =formule ;//50+(50-color)*1+(2/3))
	}
	else {
		setMultipleMotors(65,motorA,motorB);//70 //100
	}
}


/*void need_for_speed(int begin_value_s1, int begin_value_s2){
	float color;
	float  light;
	int sonar;

	light = SensorValue[S2];
	color = SensorValue[S1];
	sonar = SensorValue[S3];
	nxtDisplayTextLine(1, "color: %d", color);
	nxtDisplayTextLine(2, "light: %d", light);
	nxtDisplayTextLine(3, "sonar: %d", sonar );

	if(sonar <15) {
		setMultipleMotors(0,motorA,motorB);
		string s = "";
		check_bleutooth(&s);
	}
	else if (light < 60){
		motor(motorA) = (60+((60-light)*2));//50+((60-light)*2.5)
		motor(motorB) = 0;//35  //0
	}
	else if(color < 45) {//vorige waarde: 4
		motor(motorA) = 0;//0
		motor(motorB) = (50+(50-color)*(1+(2/3)));//50+(50-color)*1+(2/3))
	}
	else {
		setMultipleMotors(80,motorA,motorB);//70 //100
	}
}*/



int bleutooth_control(void){
	TFileIOResult nBTCmdRdErrorStatus;
  int nSizeOfMessage;
  ubyte nRcvBuffer[kMaxSizeOfMessage];
  int stopcode = 0;

  nSizeOfMessage = cCmdMessageGetSize(INBOX);

	if (nSizeOfMessage > kMaxSizeOfMessage){
      nSizeOfMessage = kMaxSizeOfMessage;
 	}

	if (nSizeOfMessage > 0){
    	nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
    	nRcvBuffer[nSizeOfMessage] = '\0';

    	string s = "";
    	stringFromChars(s, (char *) nRcvBuffer);
    	displayCenteredBigTextLine(4, s);

    	while (s != "A"){//A shuts down this loop

    		nSizeOfMessage = cCmdMessageGetSize(INBOX);//misschien onderaan
    		if (nSizeOfMessage > kMaxSizeOfMessage){
      		nSizeOfMessage = kMaxSizeOfMessage;
 				}
 				if (nSizeOfMessage > 0){
		    	nBTCmdRdErrorStatus = cCmdMessageRead(nRcvBuffer, nSizeOfMessage, INBOX);
		    	nRcvBuffer[nSizeOfMessage] = '\0';

		    	s = "";
		    	stringFromChars(s, (char *) nRcvBuffer);
		    	displayCenteredBigTextLine(4, s);
		  	}

    		if(s == "LEFT"){
    			motor(motorA) = 0;
    			motor(motorB) = 30;
    		}
    		else if(s == "RIGHT"){
    			motor(motorA) = 30;
    			motor(motorB) = 0;
    		}
    		else if (s == "UP"){
    			setMultipleMotors(50, motorB, motorA);
    		}
    		else if (s == "DOWN"){
    			setMultipleMotors(-50, motorB, motorA);
    		}
    		else {
    			setMultipleMotors(0, motorA, motorB);
    		}
    		if (s == "C"){
    			stopcode = 1;
    			break;
    		}
    	}
   }
   return stopcode;
}

/*
void junction(){
    
	string s = "";
	if (SensorValue[S1] < 38 && SensorValue[S2] < 50){
		setMultipleMotors(90, motorA, motorB);
		wait1Msec(30);
		setMultipleMotors(0, motorA, motorB);
		check_bleutooth(&s);
		if(s == "LEFT"){
			motor(motorA) = 0;
  		motor(motorB) = 40;
  		while(1){
  			if (SensorValue[S1] < 40){//color
  				setMultipleMotors(0, motorA, motorB);
  				break;
  			}
  		}
  	}
  	else if(s == "RIGHT"){
  		motor(motorA) = 40;
  		motor(motorB) = 0;
  		while(1){
  			if (SensorValue[S2] < 60){//light
  				setMultipleMotors(0, motorA, motorB);
  				break;
  			}
  		}
  	}
  	else if(s == "UP"){
    	setMultipleMotors(40, motorA,motorB);
    	wait10Msec(10);
		}
	}
}
*/
void junction(){
	string s = "";
	if (SensorValue[S1] < 38 && SensorValue[S2] < 50){
		setMultipleMotors(90, motorA, motorB);
		wait1Msec(30);
		setMultipleMotors(0, motorA, motorB);
		check_bleutooth(&s);
		if(s == "LEFT"){
			motor(motorA) = 0;
			motor(motorB) = 40;
			while(1){
				if (SensorValue[S1] < 40){//color
					setMultipleMotors(0, motorA, motorB);
					break;
				}
			}
		}
		else if(s == "RIGHT"){
			motor(motorA) = 40;
			motor(motorB) = 0;
			while(1){
				if (SensorValue[S2] < 60){//light
					setMultipleMotors(0, motorA, motorB);
					break;
				}
			}
		}
		else if(s == "UP"){
		
	
		}
	}
}

task music(){
	playTone(695, 14);
	playTone(695, 14);
	playTone(695, 14);
	playTone(929, 83);
	playTone(1401, 83);
	playTone(1251, 14);
	playTone(1188, 14);
	playTone(1054, 14);
	playTone(1841, 83);
	playTone(1401, 41);
	playTone(1251, 14);
	playTone(1188, 14);
	playTone(1054, 14);
	playTone(1841, 83);
	playTone(1401, 41);
	playTone(1251, 14);
	playTone(1188, 14);
	playTone(1251, 14);
	playTone(1054, 55);
	wait1Msec(280);
	playTone(695, 14);
	playTone(695, 14);
	playTone(695, 14);
	playTone(929, 83);
	playTone(1401, 83);
	playTone(1251, 14);
	playTone(1188, 14);
	playTone(1054, 14);
	playTone(1841, 83);
	playTone(1401, 41);
	playTone(1251, 14);
	playTone(1188, 14);
	playTone(1054, 14);
	playTone(1841, 83);
	playTone(1401, 41);
	playTone(1251, 14);
	playTone(1188, 14);
	playTone(1054, 55);
}

task main()
{
	//read the beginvalues of the light sensors
	int begin_value_s1 = SensorValue[S1];
	int begin_value_s2 = SensorValue[S2];

	//delayed startup
	/*for (int i = 0; i< 100; i+=5){
		setMultipleMotors(i, motorA, motorB);
		wait(0.1);
	}*/

	//int bt_message;
	int stopcode2 = 0;
	
	startTask (music);
	while(1){
		stopcode2 = bleutooth_control();
		junction();
		need_for_speed(begin_value_s1, begin_value_s2);
		if(stopcode2 == 1){
			return;
		}
	}
}
